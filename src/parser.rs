use std::{
    fmt::Display,
    fs::File,
    io::{BufRead, BufReader},
};

use anyhow::Result;
use regex::Regex;

const RANDOM_VARIABLE_PATTERN: &str = r"\<random(:(?P<size>\d*))?\>";
const AUTO_GENERATED_PATTERN: &str = r"\{[A-Z0-9_]+\}";

use crate::model::{
    AutoGeneratedVariable, Block, Comment, SimpleVariable, VariableType, VariableWithRandomValue,
};

enum Expecting {
    Title,
    DescriptionOrVariables,
    Variables,
}

pub struct Parser {
    pub blocks: Vec<Block>,
    buffer: Option<Block>,
    path: String,
    state: Expecting,
    random_pattern: Regex,
    auto_generated_pattern: Regex,
}

impl Parser {
    pub fn new(path: &str) -> Result<Self> {
        Ok(Self {
            blocks: vec![],
            buffer: None,
            path: path.to_string(),
            state: Expecting::Title,
            random_pattern: Regex::new(RANDOM_VARIABLE_PATTERN)?,
            auto_generated_pattern: Regex::new(AUTO_GENERATED_PATTERN)?,
        })
    }

    fn flush<T: BufRead>(&mut self, terminal: &mut T) -> Result<()> {
        if let Some(block) = self.buffer.as_mut() {
            block.resolve(terminal)?;
            self.blocks.push(block.clone());
            self.buffer = None
        }
        Ok(())
    }

    fn parse_random_variable(&self, name: &str, value: &str) -> Result<VariableWithRandomValue> {
        if let Some(matches) = self.random_pattern.captures(value) {
            let size = &matches["size"];
            let length = if size.is_empty() {
                None
            } else {
                let number: usize = size.parse()?;
                Some(number)
            };
            return Ok(VariableWithRandomValue::new(name, length));
        }
        Err(anyhow::anyhow!("Invalid random variable: {}", value))
    }

    fn parse_auto_generated_variable(
        &self,
        name: &str,
        value: &str,
    ) -> Result<AutoGeneratedVariable> {
        if self.auto_generated_pattern.find(value).is_some() {
            return Ok(AutoGeneratedVariable::new(name, value));
        }
        Err(anyhow::anyhow!(
            "Invalid auto-generated variable: {}",
            value
        ))
    }

    fn parse_variable(&self, line: &str) -> Result<VariableType> {
        let (name, rest) = line
            .split_once('=')
            .ok_or(anyhow::anyhow!("Invalid variable line: {}", line))?;
        let (default, help) = match rest.split_once("  # ") {
            Some((default, help)) => (Some(default), Some(help)),
            None => (Some(rest), None),
        };
        if let Some(val) = default {
            if let Ok(v) = self.parse_random_variable(name, val) {
                return Ok(VariableType::Random(v));
            }
            if let Ok(v) = self.parse_auto_generated_variable(name, val) {
                return Ok(VariableType::AutoGenerated(v));
            }
        }
        let variable = SimpleVariable::new(name, default, help);
        Ok(VariableType::Input(variable))
    }

    pub fn parse<T: BufRead>(&mut self, terminal: &mut T) -> Result<()> {
        let reader = BufReader::new(File::open(&self.path)?);
        for line in reader.lines() {
            let cleaned = line?.trim().to_string();
            if cleaned.is_empty() {
                self.flush(terminal)?;
                continue;
            }
            match self.state {
                Expecting::Title => {
                    if let Some(txt) = cleaned.strip_prefix('#') {
                        self.buffer = Some(Block::new(Comment::new(txt.trim()), None));
                    }
                    self.state = Expecting::DescriptionOrVariables;
                }
                Expecting::DescriptionOrVariables => {
                    if let Some(txt) = cleaned.strip_prefix('#') {
                        if let Some(b) = self.buffer.as_mut() {
                            b.description = Some(Comment::new(txt.trim()));
                        }
                        self.state = Expecting::Variables;
                    } else {
                        let variable = self.parse_variable(&cleaned)?;
                        if let Some(b) = self.buffer.as_mut() {
                            b.variables.push(variable);
                        }
                    }
                }
                Expecting::Variables => {
                    let variable = self.parse_variable(&cleaned)?;
                    if let Some(b) = self.buffer.as_mut() {
                        b.variables.push(variable);
                    }
                }
            }
        }
        self.flush(terminal)?;
        Ok(())
    }
}

impl Display for Parser {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        for block in &self.blocks {
            write!(f, "{}", block)?;
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use std::{io::Cursor, path::PathBuf};

    use super::*;

    #[test]
    fn test_parser() {
        let sample = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join(".env.sample")
            .into_os_string()
            .into_string();
        let mut parser = Parser::new(&sample.unwrap()).unwrap();
        parser.parse(&mut Cursor::new("World")).unwrap();
        assert_eq!(parser.blocks.len(), 1);
        assert_eq!(parser.blocks[0].variables.len(), 4);
        let names: [&str; 4] = ["NAME", "GREETING", "DO_YOU_LIKE_OPEN_SOURCE", "PASSWORD"];
        for (variable, expected) in parser.blocks[0].variables.iter().zip(names) {
            let got = match variable {
                VariableType::Input(v) => &v.name,
                VariableType::Random(v) => &v.name,
                VariableType::AutoGenerated(v) => &v.name,
            };
            assert_eq!(got, expected);
        }
        for (idx, variable) in parser.blocks[0].variables.iter().enumerate() {
            if idx == 0 || idx == 2 {
                match variable {
                    VariableType::Input(_) => (),
                    _ => panic!(
                        "Expected variable number {} to be Input, got {:?}",
                        idx + 1,
                        variable
                    ),
                }
            }
            if idx == 1 {
                match variable {
                    VariableType::AutoGenerated(_) => (),
                    _ => panic!("Expected variable to be AutoGenerated, got {:?}", variable),
                }
            }
            if idx == 3 {
                match variable {
                    VariableType::Random(_) => (),
                    _ => panic!("Expected variable to be Random, got {:?}", variable),
                }
            }
        }
    }
}
