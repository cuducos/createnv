mod model;
mod parser;
mod reader;
mod tokenizer;

use std::path::PathBuf;

use anyhow::Result;

use crate::parser::Parser;
use crate::{
    model::{
        AutoGeneratedVariable, Block, Comment, SimpleVariable, VariableType,
        VariableWithRandomValue,
    },
    tokenizer::Tokenizer,
};

pub fn tokenize(path: &String) -> Result<()> {
    let mut tokenizer = Tokenizer::new(PathBuf::from(path))?;
    for token in tokenizer.tokenize()? {
        println!("{}: {:?}", token.error_prefix(path), token);
    }

    Ok(())
}

pub fn parse(path: &String) -> Result<()> {
    let mut parser = Parser::new(PathBuf::from(path))?;
    for block in parser.parse()? {
        println!("{block}");
    }

    Ok(())
}

pub fn model_to_text() -> Result<()> {
    let title = Comment::new("42");
    let description = Some(Comment::new("Fourty-two"));

    let mut variable1 = SimpleVariable::new("ANSWER", None, None);
    variable1.user_input("42");
    let mut variable2 = SimpleVariable::new("AS_TEXT", None, None);
    variable2.user_input("fourty two");
    let variable3 = SimpleVariable::new("DEFAULT_VALUE_ONE", Some("default value"), None);
    let mut variable4 = SimpleVariable::new("DEFAULT_VALUE_TWO", Some("default"), None);
    variable4.user_input("custom");
    let variable5 = VariableWithRandomValue::new("SECRET_KEY", None);
    let variable6 = AutoGeneratedVariable::new("AUTO_GENERATED", "{ANSWER}-{DEFAULT_VALUE_ONE}");

    let variables = vec![
        VariableType::Input(variable1),
        VariableType::Input(variable2),
        VariableType::Input(variable3),
        VariableType::Input(variable4),
        VariableType::Random(variable5),
        VariableType::AutoGenerated(variable6),
    ];
    let block = Block::new(title, description, variables);
    println!("{block}");

    Ok(())
}
